<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e404c8b11acc4901aef772b231b8fa5c7b9ed5d746fd576c7cb9577c897902b1d26c0ddd6444919d222300e48c10ddf60e3a0fdd0a7ff6defee56d606cea68797868edc0b99d2d03673564a834b3f6db94e44ff759fec8105ce08df82f538a6367df19a2adcdb51cdbdd8431e1c54a106a36afa7ec4806607f68ea59f329813fd0270f76967bc4612eb69a8af530a0ceac44b100e4e8ac9167d5768fd31e64a6f2cf9bd3f4c874f355110a7378fd643220a540c440c1f38375ea8a9ad9b753f54566f7f909a40e726ccf2f6c0d9225b1a15870bc2aade0c081ab4dcc600764247e90306da6261512ecaaf3c710a0af07ec87c10c1d689c3f2b1ed0f016bc2554d1037d561079012f8e20caff3bed765fc64d5a0e5e226b9af12d99d4b2e6d7235517d99d366148d701c486e7b3a8ea0e54b16533d346aab55cfda056142d11e340a9c513c90d8f4f1e2beaf2e0b05f4ef439cd33dc736b5110f2bb39b2b63cae66a549e95c4f11325d4464433f2be4b2d8bf9a22579c7b049934ed566212b1eb9ed57655f472325ebf4dd4a411ad371fe430ca0ae4ae2205950433679cfcfe2cfdf7322ba6fc4737cd12799a63d38244af9e04a6d335b350372f069edb5f2ae7bd0fe9b3d7fbdf783381ee97b3a950f914791526ee2a674684f2c258e390e96046fc96321066f4c1e6b74c5fe5ba7706a4d04a5063d5c8d255b69e26f24e1a7c570a452703b0aa9d72f291ffdbd10630389eea463f1c1bcd076d76c598ef6a0bfedcdcd3efd0bd027c823fae49641eb35c8a8b451548078a490c8577be5fea4655d4caefc4e348309b044b455ef63f594109d1e361f0ffce3905df65190cdccaabd55c91a693ae36682268a5e484f67ea8b6eccd466838fe3f81dbfd0ecc0d51d46981f4b009cb1f0263ef2d208ed87563613a88a35db520ae407c982dd15fadbbfc393d84c1a2b610b41b255ed1be498d7496e7959298c39cf1305bf8a216ec5a44cc729021fa1e533910fa0770650c6303d3c6bc89c4878d2e91128cf76103e8d1126fb69ecb5f74a6f008fdd909cf0d2b547fd672654587b39cd8b1f8942070b6dd1aa4a5538c9b597c9686f048e0819acb79bce320209e46181354a246a6a5df7863ff5f0ec3c1de57d1878b9990b6e600c14219becc2a8b8bae90694a060becbbf9930bfa93362b7c1b067fe94b4d32d7b618ef0a3d6169d330441c13c130ef6034d4ba46499499f4f889653b1fd608fbcc6ca5dd95b3b558dfd4ce781d2697f98b2f1c9500c8c8d7ebcf39de0d53a9d2f8c5a559d72062fde6502be3be4fb7d208df2d09c7475d0ea91a1c5639dfa823efd4e00623febd386b35f1d70e36a905f850f0c4a1b00a7c0eea9468b526dbf25ea66c235b15a26b1572d10ad2a52881e3ff802d0d1768a58b63cf7f21bc07d7bd03b19d5088a0584f4f2ffc9a15fdc7db606751201579b20de9d47efd1216ae9a8d106bc3718513f23753ea465127583e1148194e6453990375e9296c572421f3e2fa11bd4c6aab175e4f0630524ac5202dd81a139da8c01b88642be2949d3fd9bc528efbae0ecbe8f04c4694c48adc3e98469d8f2d0856bedf12e9bd9cee27ec5a0c9e9ca5cec472023cf5a6a89c6fb3b623031d537c7ea46e4e77632bf10c7ffa357ec37942583609e7e7ec6547bd3d1b4842da7f1d0bc6338343dcf0753c1972e34bb6445de89b86abe02b60a1ac61031637abd2f3dedb00d13c1f72e28169605195d95afdc8fcbb7735a6742a594a0a115de3c2f86a58b2f09f8bbbc70be041ea0b8f68cbf93a9902a3b1cd24768af2efa7f85e6ad463aeacc3cba941834656a557a684e0a844afb23d1d261934ba2f61604c85dff11701b76d17aa4ba5ee5de8a16f5f756836789468e33473f4184328e47e802c54b54c849b306362e7da841f76639487a5e25bf8ee2924ddd1e120ddf3535f704be9baa552ac25f20ddcc9f6d1f5f646860f5887209a27847edfaa77747b5c4251764b5bcc775131b9b5284f6cb291dea9c15e4f0df5297d61f0874f21da9f160ae4a6db6bd0ed0dcd61e278dcd2513b49d121d0f2e7eaba49f9d505670ea4509c15783c92e2f804f270d2214e453657b1c14ab012c682f8e60ba2862b07c599494215c61591a27ba9f98c562b44cebfe8c50f5686c312e152790ea03d0700734a12089757786e498d6336f13e04672a3c11eb6b847e02672b292a5fbf99d2977d61694359ce36bcfea4ba92734d57c5195864b4df9e3f2033248305e32d2620f1e33a6af2759232a118752e543005c42d0a568f0f6b53cf5ccd2b051a24d0054bf0c81ad3d6ee30cef7156712d99001b03bc7e2c2403654795fe0d6a982880ad62ad6d83e04628f2ef70fb5d27b60d4f94112ed300c7e1a5322b7d12011c5b100fcd09c601b24ae5782ce630a55f17b55843aea7740f0f28bf0f62d644c258f1eab14dc4c0007348859085ef5394341204c343e90adb7761e55c9b46a844401429a87195e146391aab8b908e0f4d1ba7f393723e4d72ef8cc010fc3948a02c76583cebe794fddb14a0e1765b664bc5ac4666e07a90bd01d1060d5e1c93fe800c93e59d59a490504b9417e286cee24984379ee5fae1870f74bee7d72fd0a3b66ed218ced46e6dd15691d3cea69c861f92923ce3450699b9663fbd407d2e7659dc6f5aa1725f9912c839593fa849e7203b2e180721dd434dd0ab0e914791beedef00f023bd9bc2fada6a16f165767c3cc2a59a5788bfe3fe230cc696ee46b491e9567c0c7f12bab48c84aa504f85039cdb5da05d8844a739290ed1d145bb1fdcde0199cb7042cc95a04410ba12fa253192784e780802b70de323e2359fcf37fd9fe3198d4a0baa15365ffc7698f9961d0955528f4a6e0256fbdcf7412689590841aa2270be93850e7a803f37d6cd16f68fa7df33b519e049ce6e09f8c5461e2d9068b6cf3fdde9df3e1302a5ee8bf8c78ccbbebc5f20c3fe95bd35fc487adbffeaebc86f8431e9c8c9bb1c47914197b683483ecfe292bf333f2b0348883ee8f1df246d9bfc9f1fe1eb34687da397d9da78f1ee14e650feac88c5123a84181a5f0495ae043ff6ee23bed46c4b0276a8fe2674107d8ec65af10ced891e87255513e06ca1d3c67155c9b07ca03890e910b528f0a94613ca5325c8ed21ac3711f3fa7179a1a1594786f59a839f83a45ada52d300a076ef0d8aa77aaa60e2183611e1ebaef2b81a2544f140fbaca6c69efdca0ae80765bc3dd943c66f006b08490b961891b1b34cc76b7798cea804f7069baebf44869f2f0954814063f2df5c59d997e5583ae900b7f2b2f0503da5c990552e6cb47ddd15e86154c3fa0b56e69993cffe1f735219515f8c41204fec87dbcce2d741864c9143cdc4c4dce832066fca346cd62613ca7fa5284ea48cb619b34c0f91b9c911be795b2e6d2de9ae6337f5d4c219d91fee9a3c3c56f240af0be556944bcccfd3e4f2bfdeb666cfc277ff9a90836aeff4cfa3d613c4a35e1c532c5ab1352b158a3c4157d8449160531f9e3323a77f306eef43c7feca9fd69b15b33fd357fc51f37bcbd12f766ca4275367930253f01da61fc619933724e11e9f43ad080a4047535564b8c050e7daede979590208d68de07b005ebb391a309370a9a46acce35ae5b7dd637e78133d9fd77ef215453dab6fe23aef73fb1dda436ac0b401a66a7e50cb3fc440b63cc60a9030d8b88eb21a447da7e98760ec44f6a3f0f04b1f3a45c51d292afc4133ef98dcbbca9206410a91e03241499a634c9714401363a65ed10e0d681d54a6497f9f2275bc00e080449ff31d88bd89d2bd3d5920bfaf8475f9da8878d530e936e35999599bcf43fc29ed9ba5314a8e5098f9c25221a492c119bceafb85618b242d0df6b474240da242977046c42e1e3211b8b36122876b6d846a987b039de16cb165489143857e73e11ce16bd4cd6965b1a24478f8323a1f2584df8dc3af3ace4752763f01788775eabdccf5d4f5a702a4e9ab854aa6d2249491a87fd889db6a10e468a3fdc60dc38fd2755043de00e4978f139b03feb4d638cf72f619af8c97e63f65cafe90aa4341e91f7a11ce65095965e02d4d051ab57f128bdaffa028ddb301fa44b99cd39181a6b0090c4dfd7b2b111b173057a99349aa8729e6d8ce654a22d8fbea005f2a32cd8ab1eb23838a2102f87bc8c7b358ff46ed493ca7a22311faa34898357d9d927c57ecd51d10f5017f3f30e55070789d5de27e475a77dc744dfb87fb0a874435b9351dd3896dc4c2273a73761142681361218bc15f8e0762ee07a01f655b65d9b8ad15cd4be9ecd99825eb4a4e1e4d8fb5f0fceb860e404021471445ab808522d3e59d53c6581c95aa2ff95ced34ed57e314ee63b8e324b67c4f585f6ec99f9d802e9cd3ec02da026a9cf92764634abbb26394dd9ceadeff24ece7e41d5e7b52a4c2d269929fc5a452e166caf7a2b30b33df9ebfc1e1c56a5d4ddf8020e87e0219647b7cb1e4fdec9bfb1505397f61eedd0152c027336cd7f4ec33d5d2559e57f1a917920ac41979a6f5f9a45244d66cf7ad97cd20def8bbf841f2080518e33101e1f59ffbb0876938da35128a166a55d7cbfd27e42447e868920c706d061aadbcef39ae5c4f93ae29f829a3c533e48e8034710318fe762b1b062197877793a78d52c6bb5d5f37d9eb9d6d74fc468ce0874ff2ee609cca628551877edc0455917cd85697d44108f29a358b6fce022f266ba2c4fbf340769e6d8e42998da2ce212937a6a6a8f9acfc857ccf3a11f3a2aa900ca839883ae1d3022c6beeb298c974f61ae6341164c92ea67ed3d0910f891f011b43ba9d5664bcf8624dcd77e575986e3f8fae98e66a0cdc39ddd58c25dc9b38d90ad21489c27c3e983c2c1ad62b8bcff7598ea1390985c571baa6fe7a8379b9ed14f79e24633298fac16398d2e833527f85d85edc0f31dfc8884430d7bebaec20fb2e167bf7bcd2e973ec17e7fb6157904e0685943e2a3d2a988a6c2cc3cb70574fa2ad78a06f8da7917caffe9a0b340c02fc627866614fbc8acd319e60fca887eb0f20726dead5cd8e71449df36e5159b5b8c423b70f7d05e0163ac9aa045ac1cb8d22d3eb45fa94e0e76ed6cb9d54419cf8d4e34927e7a3bdd03ff4f00a661eac24874800b254453b3ba767d1dc9883d1277e42dea0b46fc78dfb7c72b9b50d46af9fcddaad0d6f77585b79c0f2dffd03b138988fa33f67e4a6fc6acb0cf786a3768367bc6d7987e035cd664deff7570a69bd20b25a61ddf8f339f4fdc8f6630cfa4327d9bb5efee4c1913e3d6f6e78b27b86669324cb50b030e6159de4b419743d92b3bcd5e1fb435c2c72b45e0a975f080165ce3c6f0b313f66467f8ea4cf98125801e2f4f2b3b8db2fd145e5fa7d26e6a95fa37dd7d0b307229b0c0dde2695557647d0f6251a51fdf4c466a4c5d40550b47b786f22e972d44ed930974889ca81751411e8a1bbadae52e576f8471ca134f9ba93f433ef085793ee2f69d03052c98ec9e0371a1bb398b803e0cf4678db4a30580f60b1ce8da3e60b699f84a05b03a31d342a389a9080dd4bf81a0303f1cfb81a2bc2bef9beb90e5235d11ef22fc93e139147a2a3d7e095824d683a9d8b52e62e4822bc9b20368a953b8b2f8712a693efb4a195ded00a5b5f60111137a2215911035bd31133b5b52a37055fcad33fb1752ea8e0e155919518da7a892669f972975c6cbf520ed27c25ce8bae8a9b0e9231fa38ecb322f9aeef393e59ec69d68403770c47c5e1d883d3332acad27290d9964c1f27ab207f1896b7e4f8ee6c4fe05eb4d26d7184ecf88a5689dc26c9ca12aa877e331bdda33919973b25b8fe32d844e0ddeabeabe9963c2fe16f8078a656db22dcabb373352e0062afb9c1502e13bea10000f1bf1b5e8d0c3adb6d5ce7ff5a80f3fd8da7d0afc6f2fd1ca08d6b2fc62352d761f3fb26cae8c05244d840e89c38ea1f7f67750054246715cf4cf7279445f27ece87a35eebb5625655cb814675b6df12f5bfd4812a1165fa36670bb4a9edc58f3d9d31843cbfe24730da1744440bbb74959b61c679a27ef08d6ead1cf43117801d8b4a19e9600da13eb3b6975a292bba09b4d95dca7b65c6ba9edc0cc3a99a24372c2ef936143aa66105ea4e0b0a7ff5e569bf044e92a7bee991cea107b72a75d21374c642a457c2c3ba5fd540d8efb6243ef2532464e32b540c09d03820ade681e41ca7a130448eb9aebced4efe99d6f50f6bcc0e0f6c3a36fc0441451cd659e4c3d672e780c60fd1b8bd90b823bca7dd4ad5c8fc058be4574c7c78c6d6b4c4bbfc8733879dddc56dbe720fcafefe7f13bd597a49bfc7db2f4c424ef19aae290e1bc1bc95e4c30dcefebe22d6b0b13b8bf9a340e9341ae32211e2c0918041f9aad72057d8d1475695de90a7a39c3709772bb88f7ab7318cc43faa374e9fc7e28717bff18d59acd9a3082dba449e7f203b9bb58ab738e7157d6ab02f508780d8b80928822049b9804a4a620dc3cafd538ff36cf3901b78c8b79b17c62a0b0563e0c67e34ca0ca491bfe927b014d11fa96b94062d55fff3d18232daf7ac1f5bd1d1733083e22f77b2814472fc6cd5021f43c35f9563a408de721960947753adcd0c03f00c44bdb3c2560c0c55861b8fde11ebdd3d7424cc02e72751cd9e9e3debb44b039999f91b0c727bb37403176f8d13a0a3736df047554bd2a03d5991c01b08863000b2a132881553e3b25e6f46da72060624c211ff6150d113357385c94e8b1543e147d6cddac6cf47c7d5534c078bc1237289296ad99809a3a0aa4abe88e35cc8d039b11b6bc499377ba570a937f51547043a1226ba9277cb401df7bf859ad664fca19577f6a7e7541199d4e78cef3db359e44e5342f779509cc66579b8c9baefe9a171308f1f5e014e8847864ee37a9f4d0abd8cfc2a07d12d631f5b2f02d19b391e2b26c1f815268124572ca867df6c7801e7ab13df1f03c289d686bc78dc029625074e1fe88a9c29b51d3b959473367dc09275fed2bea052859c0506839e947f0155512f78bd950bec008544e0f01b8954e41b9ceb120c822a1144ba59acbeec71c30c269a3231f2b17778340335de9da65ecb6949098f57ec3c3d15a22f8e5aaea65d49f59e0efaa83ef1356760f84722a6289ae7767594454e11968d5db672531c72e865a4c3c8f8ab3c38db413b0325575fdf8a9282c242223ad98aa9e270ca25e21daf2697a30b9ec37c2ec201e10681c1d49934fce819e43c38765d7f89b830bb589dc426f943cc385c7bfc056c842d373565763e4945a550f595a67e89ec70cb62b4a43107e341716f67bdf61aecf6317b01ecb265ba39e49b39352e308deeb84626bdf8cfbc815e39565c6445023d787e8eff300b584185fa78b32c1ef1129794971b5ba01723677f4a7aeb4a7e224988004a3b2ac2c02400c3e6e170563beb659735d4d9bd2715936511628b9b323461103f50479f71f71674e617ecb92a7041e07179692c6a8bd1802bb86319c218d059bb9a0bd5fb568485b3625a66274c521d26f3bbfe575333b911a14c52874035178ce4d457374e41bb6549e1afeb1530bbd169f23280a02ae8e6635c2df86f3b29881967a83f6b0c969dd794d9002b0e2541ca2fbe00623aaddad43b1a90464762ec40e60cac3f9ecf354fd6f108f127f46810673e36b793a68e362b0a602cfdc11ad1bebe28063295645f605c99bb60020e5bb5cf7565dccae12f7025367d6c85eb4ae958cd08a1ca3b2e5e286db6af7d1308b8a4373051303331fec8c6fe190f3d9092e4a307b39f2514c8ef9d9636863b5eedb4e228e5e73e9859b70a797076117b29a9105b4dcb00399804d785f255d2e4bf20612a29d3e4c0002aa6a0a0ce026d12e9c55b3e9e6f97bf8940a39c90bfea68af595f17b9442e2220a9f0c4097eee1a568689632e6fef1d7f31841ad9c55449ee0047f803f8cee48edcf3b9dd78cac8451095aa86d585579ff2656754be7b411d12094ec6c3d262633a517e6949863d5471676aa7de520a263bc2400fbf70693476423a295c89606d6905e57b44ae56c602954f87350b1957cd3c7fd5f2b76d9cc73d2787a87251e34e508c8c252f32fce13aaa4fdd8f4bda0a96f07a3f766db4ad311ddb51d97fb3e22e4bba3f1f13652ae5451799b4124835cb515d125720842afd137d031bfe5d111887a4d5c3bce0bcf6207912c1d8507f16a075fb132917376842b55fa65cd2077741ba01974b689581061798536999bf9394949f67f44c85a3976ef5b6b57677ea59f41a2551144d2c78a46dd18c0af24aabd90d992c0ce8e45f606441f8713fb633721b1798337e1abf60986f77788f51e8fdfbd22d37efc9fa1b84cbf8cd0f9b3e37846bd3cff1d47d8846738e9b22dd08caf86200df03f20ceba9979de1e4a49352865c5e47e10c9277d1ad8a31cedd932a08827e52341c6689508affafd05d9cb5d4bf22901d3d52ef1f8c1ca12e44fdc948e345d01d580b1200f9be52c91986e5f0372c9f8111b05e7a5e9ff31e412beac7ae3dafcd398b760634c42e5e1cb3f0127ef2ffabfce2ec7665ae3b7d708a185572b8748a60fcf7ae2cf816ac14a4c41fc98ba4ea010401d5932865fe5119d1c4273375f7b43c74ed10c409784328978147a311b5ba2b6746365051c63b6b2ca56ce16775438839a04ef00a1fecdb51646f0e7e9941c0b504812c389dbda7bf71347bdb55e76d1d7bd6e0b52e687eb05e575c61eed41d6710d4d1e645c05b69eff6801e5febc98576fb8e1b0df664d603978f07842f3e0e0bfb7f7851f4b67b2e40eb794c055cd7ee466162aed0b1ae3c68f51d1a652248b3dfd2c113c9d31c41e860c1fa2361a5a4163982cfa2e844dc5cc160913409ea8f5d1a5765e56834f5d3abfed13603198bec005807c67389554f58753fc033daf694034dff68bd229cb3b50d8bd361a9116af887563fa9d93955a27f51eb9a7a7b527d7fcdab9a9b1337aa3265939e3d3889cd5d93c6447d57852d4a2c42d0a7a24e5de911739be663fbd00d35ffb8e9f44a2d37d20c864a187df2456c5fff85ef2fc30525566de48eae8d597166a63e6545e431753edc72b548964572ef8b4ec5281a3010fd82a42c2d583835d49a8e890249d88a46b619df9d5f5e4d47a4dde9811d7a4fee07be3b8127f70e469fa17ae0bc65d67f35140191213f04a4164c0b044d42ccacbaf600b45ba82c76e202369f417112076437528c956daf5526ce053ff06656b5e72e1d28127b650fccdebd9d9b0e23f606c977499aaaaa5fc957d0271cc1c0cef211c9913039caa384393b127b1a64161d5fe2336060ac9fe91a75ffee81bbc6c345d9bae1c7afe396afad9210ef01d3c4bacd3e0c51bf963330abaff8ca291d6e07552f7f91932002eca6603ff1b05c598408a1267786a69d874ee6a54739254b4dcaaed85fd38ce455b75ccad01c10f7571fe948565cf1636d1186a760113a4c28960d6c6ce167f639bacfbf791737779a8878d02c839953c68e8e8a184c3813a3031338ebd521bcfd606ddc7672f6cd8fa9c2d87c1b35a7503a21880b9d89e6f0226609d9a2356aeb4cb9adf0ff5b42c0831be48657fcb5ebafd3f6b07bfb3effeba71f2bd2c00d238445f34afac5920e79be347b2f9ef15f2d49b81f6eb2c8b73e9263d2e7d61344d8418338fbfec608b7c64a6d736c75449273997543d8cb82ae4bb7d13a1485965e00c40d80eead88caf0f3fd21a179884a651ef333d75950cd649f1f845d6ad143a6c87c5b9e65896ea2464176a293905a76c90c040931cc4b913e8129ac1a17cd3f8b6300256cbcdd53f9dd40240858d49187e519a5c1eb8c4c014bad65df1d54b5749b517a72700c16ea286482efa0cb4f1cd88fc13fccc34d4a0a38d316c732448d057319b41593da4a4535432349dbccddeb90af5154e30f9a06c171d6a5869509de2c112db7d6d08e2341cb6eb7a62bdd1cd5d0f88547c790d23138a27e786d6dd241c423bc30628f90a5d44cbe45043c1350239672f772a759225a6cf1b1dff39ee1a9e8b805dca25598568f5cd4d5753799c43a66ad62d9b18aadbceb5594c24fd6aefc9849f3afc63d61274712fbde3d9b44104d3fa33a09de7143adb8d6947a0c9683c1cec4efd608bc81b5dbf64766f8c39fba9ea7ac5be2052beedfc300c36558e16e6698ba84bd823bfdd3a545474c558304ad50aa2b285b41b31285c15a5da313493207cf6fd690d1181d62bfcdc5c0090a1dbe371a2859a568759d1d1d84b05645d40d49f5278a8a1c8e4ae71964bfabca10c61d42bad9e78dfea8ab656414f13b58b0688d7a3afa61240a46bbff545b7277846751666a71fff53a70d783510680bd8de061d21f375de1c6dc0c5c123d350940758dd4eebc15e152b364a00e3db1e2718e334033e41407ba446d6049175b9fa86d51f2af4a5f2ffa57acd7284e2d5a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"195d87c505529e92a2ab6acdbce68089"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
